# 观察者模式定义

观察者模式又叫发布-订阅模式（MQ），定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者，使他们能够自动更新自己

![img](https://github.com/andochiwa/Design-Pattern/blob/master/Visitor-Pattern/img.png)

`Subject`类，抽象主题或抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个聚集里，每一个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加或删除观察者对象

`Observer`类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或一个接口实现，更新接口通常包含一个`Update()`方法，这个方法叫做更新方法

`ConcreteSubject`类，具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现

`ConcreteObserver`，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题的对象的引用。具体观察者角色通常用一个具体子类实现。



# 事件委托

观察者模式的问题：抽象通知者依赖了抽象观察者，耦合度很高，并且在update时所有对象的更新动作都一致

可以用事件委托来解决，委托是一种引用类型，为委托分配方法将可以让委托与分配的方法绑定，可以搭载多个方法，所有方法都被依次调用（java可以使用反射实现）。这样通知者和观察者可以互相不通信，由客户端来决定通知谁

